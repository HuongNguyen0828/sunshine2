/**
 * AI-Generated Code Citation
 * Generated by: Claude Code (Anthropic)
 * Prompt: "Implement form state persistence across all forms in the web-admin dashboard"
 * Date: 2025-10-14
 */

'use client';

import { useEffect, useState, useCallback, useRef } from 'react';

interface UseFormDraftOptions<T> {
  formKey: string;
  initialData: T;
  onRestore?: (data: T) => void;
}

interface UseFormDraftReturn<T> {
  isDraftRestored: boolean;
  saveDraft: (data: T) => void;
  clearDraft: () => void;
  restoreDraft: () => T | null;
}

/**
 * Custom hook for managing form draft state in sessionStorage
 *
 * @param formKey - Unique identifier for the form (e.g., 'teacher-form', 'class-form')
 * @param initialData - Initial/empty state of the form
 * @param onRestore - Optional callback when draft is restored
 * @returns Object with draft management functions and state
 *
 * @example
 * const { isDraftRestored, saveDraft, clearDraft } = useFormDraft({
 *   formKey: 'teacher-form',
 *   initialData: { firstName: '', lastName: '', email: '' },
 *   onRestore: (data) => setFormData(data)
 * });
 */
export function useFormDraft<T extends Record<string, any>>({
  formKey,
  initialData,
  onRestore,
}: UseFormDraftOptions<T>): UseFormDraftReturn<T> {
  const [isDraftRestored, setIsDraftRestored] = useState(false);
  const storageKey = `form-draft-${formKey}`;
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Save draft to sessionStorage with debouncing
  const saveDraft = useCallback((data: T) => {
    // Clear existing timeout
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }

    // Debounce save by 500ms
    saveTimeoutRef.current = setTimeout(() => {
      try {
        // Only save if there's actual data (not all empty values)
        const hasData = Object.values(data).some(value => {
          if (Array.isArray(value)) return value.length > 0;
          if (typeof value === 'string') return value.trim() !== '';
          if (typeof value === 'number') return value !== 0;
          return value != null;
        });

        if (hasData) {
          sessionStorage.setItem(storageKey, JSON.stringify(data));
        }
      } catch (error) {
        console.error('Failed to save form draft:', error);
      }
    }, 500);
  }, [storageKey]);

  // Clear draft from sessionStorage
  const clearDraft = useCallback(() => {
    try {
      sessionStorage.removeItem(storageKey);
      setIsDraftRestored(false);
    } catch (error) {
      console.error('Failed to clear form draft:', error);
    }
  }, [storageKey]);

  // Restore draft from sessionStorage
  const restoreDraft = useCallback((): T | null => {
    try {
      const stored = sessionStorage.getItem(storageKey);
      if (stored) {
        const parsed = JSON.parse(stored) as T;
        setIsDraftRestored(true);
        return parsed;
      }
    } catch (error) {
      console.error('Failed to restore form draft:', error);
    }
    return null;
  }, [storageKey]);

  // Auto-restore on mount
  useEffect(() => {
    const draft = restoreDraft();
    if (draft && onRestore) {
      onRestore(draft);
    }
  }, [restoreDraft, onRestore]);

  return {
    isDraftRestored,
    saveDraft,
    clearDraft,
    restoreDraft,
  };
}
